\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,enumerate}
\usepackage{geometry}
\geometry{hmargin=2cm, vmargin=2.5cm}

\begin{document}


\section{main}%Modules for higher level coordination of the game
%#\includegraphics[scale=1]{../../../image/item/hp_plus.png}


This is the game's main module.
Its sole purpose is to create an instance of the game and run it.
It's beneficial to have such a module,
as it can be easily modified for tasks like running the game multiple times
or analyzing and possibly saving data produced during gameplay,
all without modifying the game's actual code.

\section{game}
The game module initiates a rendering loop of three phases, as it is classical for video games:
\begin{enumerate}
    \item Handle user input
    (i.e., check for keyboard and mouse events
    and delegate the input to the corresponding modules to process the reactions)
    \item Calculate game logic
    (Calculate the spawning, movement, animation, collision and killing of sprites;
    handle damage and status effects,
    update graphical user interface (statusbar and menu))
    \item Render the game's current state
    (Render the background, graphical user interface and all sprites on the screen in the correct order)
\end{enumerate}

It is crucial to keep these three phases strictly separated.
Failing to do so can quickly complicate the game's code,
making it difficult to understand and develop further.

Pygame provides the necessary methods to measure the time $dt$
passed (in milliseconds) between the rendering of two subsequent frames.
This time is passed to all game objects to ensure the game runs at the same speed on every computer.

\section{level}
The level module contains the design of the game's levels,
along with methods to control starting new levels and checking the player's progress
to determine when a level's goal is fulfilled and the next level should be loaded.
It includes convenience methods to spawn aliens, making it as easy as possible to add new levels to the game.

The update method checks for sprite collisions;
upon collision, it delegates the tasks of inflicting damage,
spawning items, splitting asteroids, and merging blobs to the corresponding modules.

\section{display}
It was necessary to set a fixed resolution for developing the game:
I used a $1600\times 900$ window, which I subdivided into a $16\times9$ square grid for planning the levels
and adjusting the sizes and velocities of the game's sprites.

The display module's task is to check the user's screen settings and set up a game surface on their screen.
This surface is intended to be as large as possible while maintaining the same $16:9$ aspect ratio as the development resolution.
If the user's screen has a different aspect ratio, the game surface will be centered with dark grey padding visible on its sides.
In any case, the dimensions of the game surface and its square grid are saved as global variables for use by other modules.

\section{settings}
This module is a structured collection of all in-game parameters,
allowing for comfortable adjustment and the creation of new templates for aliens, bullets, and items.

\section{image}%Modules for sprites of level objects
It is convenient to create a class that handles loading, preprocessing, and further editing of images used for game object sprites.
In Pygame, the \emph{Surface} class handles image files,
but since it is coded in C, it's apparently not possible to inherit properties directly from it.
Therefore, I created a wrapper class, \emph{Image}, whose objects contain
a Pygame surface, the file link from which the image was originally loaded, and a Pygame \emph{Mask} object for convenience.
In Pygame, masks are bitmaps on surfaces that can be calculated from the surface's background color
(frequently called \emph{colorkey} in this module) to enable pixel-perfect collision detection between sprites.
Including them in the Image objects is convenient, as it prevents calculating them more often than necessary.

The most complex part of the Image class is its lazy image loader.
On one hand, this loader ensures that each original image is loaded and preprocessed only once.
(This significantly improves the game's performance.
Also, adding new pictures for further development is more comfortable as the preprocessing step is automated,
and object sizes can be easily adjusted later.)
On the other hand, it loads each image directly in the optimal resolution,
adapted to the user's display settings determined in the \emph{display} module.

It would certainly be easier to fix a single scaling for the images
(for example, to rescale them all to the $1600\times900$ development resolution)
and then rescale them further if the user's display settings differ.
However, I favored the idea that if a user has a much larger screen than mine,
the images would also be loaded in a better resolution without quality loss from upscaling.
(Specifically, the original asteroid images are in a very high resolution that would be lost
by adapting them to a single, arbitrarily fixed development resolution.)
To generalize these ideas for animated images,
the dataclass \emph{GraphicData} consists either of a single image loaded from a file path
or a list of images (called \emph{frames}) loaded from a folder path, together with their mask(s).
For animated images, one can provide the description of its animation type (as a string) and its animation speed, either by its \emph{fps} (frames per second), the duration of each frame, or the total duration of its animation. The missing attributes are automatically calculated upon initializing a GraphicData object using the formula $fps = \#frames / animationtime$.

\section{sprite}
Pygame's \emph{Sprite} class is minimally designed to contain image data for in-game objects,
along with a Pygame \emph{Rectangle} object as an attributeâ€”a rectangle on the screen with integer coordinates.
It includes implemented methods to draw sprites onto their given rectangle,
detect collisions (either by checking their entire rectangles or by pixel-perfect collision calculated from their masks and rectangles),
and organize sprites into Pygame \emph{SpriteGroup}s, where they can be easily added or removed.

My implemented \emph{Sprite} class inherits these methods, and its objects consist of
a \emph{GraphicData} object (see the \emph{image} module),
moving data comprising three $2d$ vectors $pos$, $vel$ and $acc$ describing the object's position, velocity, and acceleration on the screen,
as well as information about the area where the object can move and its behavior upon hitting that area's boundary.
The vectors are implemented as objects of the \emph{Vector} class from the \emph{physics} module;
it would also have been possible to use the \emph{Vector2} class from Pygame.
I deliberately avoided using \emph{numpy}, which apparently only offers better performance for calculations involving large arrays.
For calculating sprite animations, \emph{ActionTimer}s from the \emph{timer} module are utilized.

The most important game objects (\emph{aliens}, the player's \emph{ship}, \emph{bullets}, \emph{items})
are all realized through classes that inherit from \emph{Sprite}, incorporating more specific attributes and methods.
Their initialization functions are each designed so that the full sprite data doesn't need to be provided every time a new object is created.
Instead, type-specific data is captured in \emph{AlienData}, \emph{BulletData}, and \emph{ItemData} objects
defined in the \emph{settings} module,
while other attributes like velocity and boundary behavior are often set automatically via default values or externally by the \emph{level} module.
Consequently, the parent class \emph{Sprite} needs to be somewhat complex,
while the derived classes \emph{Alien}, \emph{Ship}, \emph{Bullet}, and \emph{Item} become quite convenient to work with.

For further convenience, sprites can also be initialized without a position vector.
They will then not be rendered or updated by the game's logic until a position is provided by the \emph{Sprite.spawn} method.
This allows for easily spawning multiple instances of an object at various points,
as well as implementing other interesting features, such as aliens temporarily becoming invisible while still not counting as defeated.

\section{timer}
\emph{Actiontimers} are used in the game for certain events that need to be timed only once
(like the duration of an item's effect, one-time animations, or the level timer in the game's fifth level)
or with a cyclic repetition (like animation loops, enemy spawning, or enemy actions).
Cyclic actions can also incorporate some randomness (used for enemy spawning and actions)
by only specifying a lower and an upper bound for the duration of each repetition.

\section{alien}
All enemies in the game are implemented as objects of an \emph{Alien} class.
It includes methods to control enemy actions, inflict damage, and kill them.
Enemies can also split or merge (used for large asteroids or blobs, respectively),
invoking the realistic physics formulas for elastic or inelastic collisions from the physics module.
(To this end, the enemies are modeled as 3D balls.)
The blob is the only enemy whose image needs to be updated manually upon changes to its health
(its width rescales with its energy such that, modeling blobs as 3D balls, the total blob mass is preserved upon splitting or merging).

\section{ship}
The Ship class manages controlling the player's ship movement and shield, shooting bullets, and status effects upon collecting items.
While some status effects are permanent until the player loses a life, some have a fixed duration,
and some also require changing the ship's sprite image.
It ensures that the bullet's fire points (i.e., the points from which they are shot from the ship)
scale correctly with changes in the ship's size.

\section{bullet}
\emph{Bullet}s store their owner as an attribute.
When reflected by the player's shield, an enemy's bullet becomes the player's bullet, allowing it to subsequently hit enemies.
The blob's bullets (called blubber) rescale in size depending on the blob's dimensions.

\section{item}
\emph{Item}s are simply sprites with a fixed falling rate.
When the player has collected the \emph{magnet}, items are attracted by the ship horizontally.
I intentionally did not implement a vertical attraction (which would look more realistic)
to make it easier for the player to dodge unwanted bad items.

\section{physics}%Physics for calculating collisions of level objects
When two point masses $m_1$ and $m_2$ with velocity vectors $v_1$, $v_2$ collide,
their total momentum $$P = m_1v_1+m_2v_2$$ is preserved, and there are classically two extreme cases for the outcome:
\begin{enumerate}
\item \emph{Elastic collision}:
We assume that the two masses bounce off each other with new velocity vectors $v_1'$ and $v_2'$
without losing any energy due to friction or deformation.
Then the total kinetic energy
$$E=\frac12m_1|v_1|^2+\frac12m_2|v_2|^2=\frac12m_1|v_1'|^2+\frac12m_2|v_2'|^2$$
of the system must be preserved, and thus
$$m_1(|v_1|^2-|v_1'|^2)=m_2(|v_2'|^2-|v_2|^2).$$
Preservation of the total momentum implies
$$m_1(v_1-v_1')=m_2(v_2'-v_2).$$
In one dimension, and given that
$v_1\neq v_2$ (otherwise the two masses move parallel, meaning there is no collision),
these two equations can be resolved to yield the classical formulas
\begin{align*}
v_1'&=\frac{m_1-m_2}{m_1+m_2}v_1+\frac{2m_2}{m_1+m_2}\\
v_2'&=\frac{2m_1}{m_1+m_2}v_1+\frac{m_2-m_1}{m_1+m_2}.
\end{align*}
In two dimensions, the direction of the collision plays a role.
Let $n$ be a normal vector at the point of collision.
(In particular, for two colliding 2D balls at positions $p_1$ and $p_2$,
we can simply take $n=\frac{p_1-p_2}{|p_1-p_2|}$,
which is a normal vector to both balls at the point of collision.)
Then the formula for the 1D elastic collision can be applied in the normal direction $n$,
as no collision occurs in the parallel direction.
\item \emph{Totally inelastic collision}:
The two masses merge together into a single mass $M=m_1+m_2$
centered at the center of mass $\displaystyle\frac{m_1+m_2}{m_1v_1+m_2v_2}=\frac{P}{M}$
and with some new velocity vector $v$.
Preservation of the total momentum implies $P=Mv$,
and hence $\displaystyle v=\frac PM=\frac{m_1v_1+m_2v_2}{m_1+m_2}$.
\end{enumerate}

\section{text}%Graphical user interface
\section{menu}
\section{statusbar}


\section{highscores}%Further game features
\section{sound}
The class \emph{Sound} was merely supposed to be a simple sound library.
However, I noticed that when working in a docker container on a Windows computer,
it is non-trivial to give the game access to the sound hardware of the computer from inside of the container.
Hence I introduced a way to mute the game that not only sets the volume to zero,
but which prevents the initialization of the pygame.mixer sound module in the first place.
When the sounds are supposed to get initialized in muted mode,
they become initialized as objects of the a mock class \emph{MuteSound},
which is coded to not do anything when called via the usual play, stop or volume methods of pygame.mixer.Sound.
The upshot is that for implementing this functionality, I did not need to modify the game's core code anymore.

\end{document}